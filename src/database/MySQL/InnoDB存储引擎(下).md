---
title: InnoDB存储引擎（下）
date: 2023-06-16
---

## InnoDB数据存储结构

从`MySQL 5.5` 版本开始默认使用 `InnoDB` 作为引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日常开发中使用非常广泛。

**InnoDB数据存储结构，主要分为行、页、区、段、表空间几部分，如下图所示**：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306161935477.png" alt="image-20230616193459203" style="zoom: 80%;" />

## 行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`。在`InnoDB`存储引擎中有4种不同类型的`行格式`，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式。

### 指定行格式

我们可以通过在创建或修改表的语句中指定记录所使用的行格式

~~~ mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
~~~

~~~~ mysql
ALTER TABLE 表名 ROW_FORMAT=行格式名称
~~~~

### COMOACT 格式

一个完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分

![image-20230617103144877](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171031137.png)



#### 变长字段长度列表

MySQL 支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、`TEXT类型`，`BLOB类型`，这些数据类型修饰列称为**变长字**段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。

这些变长字段占用的存储空间分为两部分：

- 真正的数据内容
- 占用的字节数

在 `Compact`行格式中，把**所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表**，同时各变长字段数据占用的字节数`按照列的顺序逆序存放`。

> 注意：
>
> - 这里面**存储的变长长度和字段顺序是反过来的**。
>
>   比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。
>
> - 变长字段长度列表中只存储值为 **非NULL** 的列内容占用的长度，值为 **NULL** 的列的长度是不储存的 

以 record_format_demo 表中的第一条记录来举个例子。因为 record_format_demo 表的`c1`、`c2`、`c4`列都是`VARCHAR(10)`类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为record_format_demo 表中的各个列都使用的是`ascii`字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

| 列名 | 存储内容 | 内容长度（十进制表示） | 内容长度（十六进制表示） |
| ---- | -------- | ---------------------- | ------------------------ |
| c1   | 'aaaa'   | 4                      | 0x04                     |
| c2   | 'bbb'    | 2                      | 0x03                     |
| c4   | 'd'      | 1                      | 0x01                     |

又因为这些长度值需要按照列的逆序存放，所以最后`变长字段长度列表`的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：

~~~ tex
06 04 08
~~~

把这个字节串组成的`变长字段长度列表`填入上边的示意图中的效果就是：

![image-20230617120847746](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171208807.png)

具体的SQL语句：

~~~ mysql
mysql> USE xiaohaizi;
Database changed

mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;

mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
~~~

#### NULL 值列表

我们知道表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中。如果果表中没有允许存储 **NULL** 的列，则 NULL值列表 也不存在了。

每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：

- 二进制位的值为`1`时，代表该列的值为`NULL`。
- 二进制位的值为`0`时，代表该列的值不为`NULL`。

> 同时 MySQL 规定 `NULL值列表` 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。
>
> 

再看 `record_format_demo` 中的两条记录中的`NULL值列表`应该怎么储存。因为只有`c1`、`c3`、`c4`这3个列允许存储`NULL`值，所以所有记录的`NULL值列表`只需要一个字节，同时二进制位按照列的顺序逆序排列，所以第一个列`c1`和最后一个二进制位对应

- 对于第一条记录来说，`c1`、`c3`、`c4`这3个列的值都不为`NULL`，所以它们对应的二进制位都是`0`，画个图就是这样：

  ![image-20230617110257617](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171102668.png)

  所以第一条记录的`NULL值列表`用十六进制表示就是：`0x00`。

- 对于第二条记录来说，`c1`、`c3`、`c4`这3个列中`c3`和`c4`的值都为`NULL`，所以这3个列对应的二进制位的情况就是：

  ![image-20230617110434307](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171104353.png)

  

  所以第二条记录的`NULL值列表`用十六进制表示就是：`0x06`。

所以这上述两条记录在填充了`NULL值列表`后的示意图就是这样：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171214662.png" alt="image-20230617121431586" style="zoom:80%;" />

#### 记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171158208.png" alt="image-20230617115843102" style="zoom: 80%;" />

记录头信息中的各个属性的描述，如下表所示：

|     名称     | 大小（单位：bit） |                             描述                             |
| :----------: | :---------------: | :----------------------------------------------------------: |
|   预留位1    |         1         |                           没有使用                           |
|   预留位2    |         1         |                           没有使用                           |
| delete_mask  |         1         | 标记该记录是否被删除。<br>同时这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为所谓的`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。 |
| min_rec_mask |         1         |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|   n_owned    |         4         |                   表示当前记录拥有的记录数                   |
|   heap_no    |        13         |                    当前记录在本页中的位置                    |
| record_type  |         3         | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录 |
| next_record  |        16         | 当前记录的真实数据到下一条记录的真实数据的地址偏移量（存储形成单向链表，才提高范围查询的速度） |

#### 记录真实数据

记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：

|      列名      | 是否必须 | 占用空间 |          描述          |
| :------------: | :------: | :------: | :--------------------: |
|     row_id     |    否    |  6字节   | 行ID，唯一标识一条记录 |
| transaction_id |    是    |  6字节   |         事务ID         |
|  roll_pointer  |    是    |  7字节   |        回滚指针        |

> 实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。

`InnoDB`表对主键的生成策略：

- 优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。

  所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 ***transaction_id*** 和 ***roll_pointer*** 这两个列，但是 ***row_id*** 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。

这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

#### CHAR(M)列的存储格式

对于 **CHAR(M)** 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。

#### 小结

表`record_format_demo`并没有定义主键，所以`MySQL`服务器会为每条记录增加上述的3个列。现在看一下加上`记录的真实数据`的两个记录长什么样吧：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171405962.png" alt="image-20230617140531712" style="zoom:67%;" />

### Redundant行格式

`Redundant`行格式是`MySQL5.0`之前用的一种行格式，也就是说它已经非常老了。

Redundant 行格式具体如下：

![image-20230617143202639](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171432798.png)



把表`record_format_demo`的行格式修改为`Redundant`:

~~~ mysql
mysql> ALTER TABLE record_format_demo ROW_FORMAT=Redundant;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0
~~~

在`Redundant`行格式下的两条记录的真实存储数据的样貌：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171440947.png" alt="image-20230617144038845" style="zoom: 80%;" />

#### 字段长度偏移列表

Redundant 行格式的开头是**字段长度偏移列表**，与Compact行格式 的变长字段长度列表有两处不同：

- 没有了变长两个字，意味着Redundant 行格式会**把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表**。
- 多了个偏移两个字，这意味着**计算列值长度的方式不像 Compact 行格式那么直观**，它是采用**两个相邻数值的差值来计算各个列值的长度**。

例如：

比如第一条记录的**字段长度偏移列表**就是：

~~~ tex
25 24 1A 17 13 0C 06
~~~

因为它是逆序排放的，所以按照列的顺序排列就是：

~~~ tex
06 0C 13 17 1A 24 25
~~~

按照**两个相邻数值的差值来计算各个列值的长度**就是：

~~~ tex
第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。

第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。

第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。

第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。

第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。

第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。

第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。
~~~

#### 记录头信息

Redundant 行格式的记录头信息占用**6字节，48个二进制位**，这些二进制位代表的意思如下：

|      名称       | 大小（单位：bit） |                             描述                             |
| :-------------: | :---------------: | :----------------------------------------------------------: |
|     预留位1     |         1         |                           没有使用                           |
|     预留位2     |         1         |                           没有使用                           |
|   delete_mask   |         1         |                     标记该记录是否被删除                     |
|  min_rec_mask   |         1         |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|     n_owned     |         4         |                   表示当前记录拥有的记录数                   |
|     heap_no     |        13         |                表示当前记录在页面堆的位置信息                |
|     n_field     |        10         |                      表示记录中列的数量                      |
| 1byte_offs_flag |         1         | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的 |
|   next_record   |        16         |                   表示下一条记录的绝对位置                   |

第一条记录中的头信息是：

~~~ tex
00 00 10 0F 00 BC
~~~

根据这六个字节可以计算出各个属性的值，如下：

~~~ tex
预留位1：0x00
预留位2：0x00
delete_mask: 0x00
min_rec_mask: 0x00
n_owned: 0x00
heap_no: 0x02
n_field: 0x07
1byte_offs_flag: 0x01
next_record:0xBC
~~~

与Compact 行格式的记录头信息对比来看，有两处不同：

- `Redundant`行格式多了`n_field`和`1byte_offs_flag`这两个属性。
- `Redundant`行格式没有`record_type`这个属性。

> 其中，n_fields：代表一行中列的数量，占用10位，这也很好地解释了为什么MySQL一个行支持最多的列为1023。
>
> 1byte_offs_flags，该值定义了偏移列表占用1个字节还是2个字节。
>
> - 当它的值为1时，表明使用1个字节存储。
> - 当它的值为0时，表明使用2个字节存储。

**1byte_offs_flag 的值是怎么选择的**

我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条Redundant行格式记录的真实数据占用的总大小来判断的：

- 当记录的真实数据占用的字节数不大于127（十六进制`0x7F`，二进制`01111111`）时，每个列对应的偏移量占用1个字节
- 当记录的真实数据占用的字节数大于127，但不大于32767（十六进制`0x7FFF`，二进制`0111111111111111`）时，每个列对应的偏移量占用2个字节。

> 有没有记录的真实数据大于32767的情况呢？
>
> 有，不过此时的记录已经存放到了溢出页中，在本页中只保留前`768`个字节和20个字节的溢出页面地址（当然这20个字节中还记录了一些别的信息）。因为`字段长度偏移列表`处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。

#### NULL值的处理

因为`Redundant`行格式并没有`NULL值列表`，所以在`字段长度偏移列表`中的各个列对应的偏移量处做了一些特殊处理。

将列对应的偏移量值的第一个比特位作为是否为`NULL`的依据，该比特位也可以被称之为`NULL比特位`。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的`NULL比特位`是不是为`1`，如果为`1`，那么该列的值就是`NULL`，否则不是`NULL`。

这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制`0x7F`，二进制`01111111`）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的`NULL比特位`，用来标记该列的值是否为`NULL`。

但是还有一点要注意，对于值为`NULL`的列来说，该列的类型是否为定长类型决定了`NULL`值的实际存储方式。

我们接下来分析一下`record_format_demo`表的第二条记录，它对应的`字段长度偏移列表`如下：

~~~ tex
A4 A4 1A 17 13 0C 06
~~~

按照列的顺序排放就是：

~~~ T
06 0C 13 17 1A A4 A4
~~~

我们分析一下情况：

- 如果存储`NULL`值的字段是定长类型的，比方说`CHAR(M)`数据类型的，则`NULL`值也将占用记录的真实数据部分，并把该字段对应的数据使用`0x00`字节填充。

  如图第二条记录的`c3`列的值是`NULL`，而`c3`列的类型是`CHAR(10)`，占用记录的真实数据部分10字节，所以我们看到在`Redundant`行格式中使用`0x00000000000000000000`来表示`NULL`值。

  另外，`c3`列对应的偏移量为`0xA4`，它对应的二进制实际是：`10100100`，可以看到最高位为`1`，意味着该列的值是`NULL`。将最高位去掉后的值变成了`0100100`，对应的十进制值为`36`，而`c2`列对应的偏移量为`0x1A`，也就是十进制的`26`。`36 - 26 = 10`，也就是说最终`c3`列占用的存储空间为10个字节。

- 如果该存储`NULL`值的字段是变长数据类型的，则不在`记录的真实数据`处占用任何存储空间。

  比如`record_format_demo`表的`c4`列是`VARCHAR(10)`类型的，`VARCHAR(10)`是一个变长数据类型，`c4`列对应的偏移量为`0xA4`，与`c3`列对应的偏移量相同，这也就意味着它的值也为`NULL`，将`0xA4`的最高位去掉后对应的十进制值也是`36`，`36 - 36 = 0`，也就意味着`c4`列本身不占用任何`记录的实际数据`处的空间。

#### CHAR(M)列的存储格式

`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在`Redundant`行格式中十分干脆，不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积。

比方说使用`utf8`字符集的`CHAR(10)`类型的列占用的真实数据空间始终为`30`个字节，使用`gbk`字符集的`CHAR(10)`类型的列占用的真实数据空间始终为`20`个字节。由此可以看出来，使用`Redundant`行格式的`CHAR(M)`类型的列是不会产生碎片的。

### 行溢出

MySQL是以页为基本单位来管理存储空间的，**我们的记录都会被分配到某个页中存储**。而一个页的大小一般是16KB，也就是16384字节，而一个`VARCHAR(M)`类型的列就最多可以存储**65532个字节**，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Redundant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：

![image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171512024.webp)

从图中可以看出来，对于`Compact`和`Redundant`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。画一个简图就是这样：

![image-20230617151636082](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171516152.png)

> ps：
>
> - VARCHAR(M)类型的列做到可以占用 65535个字节，但如果我们将该类型的列设置为65535个字节就会出现如下的错误：
>
>   ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have  to  change  some  columns  to  TEXT or  BLOBs
>
>   报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外， 其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。
>
>   这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。
>
>   如果没有NOT NULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用 2个字节，NULL值标识需要占用1个字节。
>
> - 不只是 ***VARCHAR(M)*** 类型的列，其他的 ***TEXT***、***BLOB*** 类型的列在存储数据非常多的时候也会发生`行溢出`。

### Dynamic和Compressed行格式

现在使用的`MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`，这俩行格式和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![image-20230617152019538](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171520618.png)

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

## 页结构

### 基本介绍

页是 InnoDB 管理存储空间的基本单位，一个页的大小一般是`16KB`。InnoDB 为了不同的目的而设计了许多种不同类型的`页`，比如存放表空间头部信息的页，存放`Insert Buffer`信息的页，存放`INODE`信息的页，存放`undo`日志信息的页等等等等。

页的整体结构图，如图所示：

![微信图片_20230616220228](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171525300.png)

`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：

![image-20230617153715758](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171537832.png)

一个`InnoDB`数据页的存储空间大致被划分成了`7`个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。我们用表格的方式来大致描述一下这7个部分分别存储的内容：

|        名称        |       中文名       | 占用空间大小 |         简单描述         |
| :----------------: | :----------------: | :----------: | :----------------------: |
|    File Header     |      文件头部      |    38字节    |     页的一些通用信息     |
|    Page Header     |      页面头部      |    56字节    |   数据页专有的一些信息   |
| Infimum + Supremum | 最小记录和最大记录 |    26字节    |     两个虚拟的行记录     |
|    User Records    |      用户记录      |    不确定    |   实际存储的行记录内容   |
|     Free Space     |      空闲空间      |    不确定    |    页中尚未使用的空间    |
|   Page Directory   |      页面目录      |    不确定    | 页中的某些记录的相对位置 |
|    File Trailer    |      文件尾部      |    8字节     |      校验页是否完整      |

### 记录在页中的存储

我们存储的记录会按照我们指定的`行格式`存储到`User Records`部分。

在一开始生成页的时候，其实并没有`User Records`这个部分，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

![image_1cosvi1in9st476cdqfki1n39m.png-133.8kB](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171545217.webp)



### Infimum + Supremum

在记录头信息`heap_no`会在值为 0 和 1 分别记录了最小记录和最大记录，同时InnoDB会自动给每个页里面加这两个记录，由于这个两个记录并不是我们自己插入的，所以有时候也成称为 伪记录 和 虚拟记录。

对于一条完整的记录来说，比较记录的大小就是比较`主键`的大小。比方说我们插入的4行记录的主键值分别是：`1`、`2`、`3`、`4`，这也就意味着这4条记录的大小从小到大依次递增。

但是不管我们向`页`中插入了多少自己的记录，`InnoDB`规定这两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的`记录头信息`和8字节大小的一个固定的部分组成的，如图所示:

![image_1c9ra45eam7t1mil9o1h3ucqdhv.png-50.4kB](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171620887.webp)



由于这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分，它们具体的作用就是将我们页内的所有记录给串联起来，统一管理，这里就使用到了记录头的 `next_record` 指针如图所示：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171623686.webp" alt="image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB" style="zoom:80%;" />

我们的记录按照主键从小到大的顺序形成了一个单链表。`最大记录`的`next_record`的值为`0`，这也就是说最大记录是没有`下一条记录`了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：

![image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171624823.webp)

从图中可以看出来，删除第2条记录前后主要发生了这些变化：

- 第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
- 第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
- 第1条记录的`next_record`指向了第3条记录。
- 同时最大记录的`n_owned`值从`5`变成了`4`

> 1. 为啥要指向记录头信息和真实数据之间的位置呢？为什么不指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？
>
>    变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。也即是向左读取就是记录头信息，向右读取就是真实数据。
>
> 2. 主键值为`2`的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？
>
>    当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

### 页目录

在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，提高检索的效率，制作流程如下：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171635165.webp" alt="image_1couapvdmb5mvm1i0l5m0vcb2a.png-128.2kB" style="zoom: 80%;" />

InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 **1** 条记录，最大记录所在的分组拥有的记录条数只能在 **1~8** 条之间，剩下的分组中记录的条数范围只能在是 **4~8** 条之间。所以分组是按照下边的步骤进行的：

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171640522.webp" alt="image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB" style="zoom: 80%;" />



**在一个数据页中查找指定主键值的记录的过程分为两步**：

1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

### Page Header（页面头部）

为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫`Page Header`的部分，它是`页`结构的第二部分，这个部分占用固定的`56`个字节，专门存储各种状态信息。



|        名称         | 占用空间大小 |                             描述                             |
| :-----------------: | :----------: | :----------------------------------------------------------: |
| `PAGE_N_DIR_SLOTS`  |   `2`字节    |                      在页目录中的槽数量                      |
|   `PAGE_HEAP_TOP`   |   `2`字节    | 还未使用的空间最小地址，也就是说从该地址之后就是`Free Space` |
|    `PAGE_N_HEAP`    |   `2`字节    | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
|     `PAGE_FREE`     |   `2`字节    | 第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用） |
|   `PAGE_GARBAGE`    |   `2`字节    |                    已删除记录占用的字节数                    |
| `PAGE_LAST_INSERT`  |   `2`字节    |                      最后插入记录的位置                      |
|  `PAGE_DIRECTION`   |   `2`字节    | 记录插入的方向<br>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是`PAGE_DIRECTION` |
| `PAGE_N_DIRECTION`  |   `2`字节    | 一个方向连续插入的记录数量。<br>假设连续几次插入新记录的方向都是一致的，`InnoDB`会把沿着同一个方向插入记录的条数记下来，这个条数就用`PAGE_N_DIRECTION`这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。 |
|    `PAGE_N_RECS`    |   `2`字节    | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
|  `PAGE_MAX_TRX_ID`  |   `8`字节    |        修改当前页的最大事务ID，该值仅在二级索引中定义        |
|    `PAGE_LEVEL`     |   `2`字节    |                   当前页在B+树中所处的层级                   |
|   `PAGE_INDEX_ID`   |   `8`字节    |                索引ID，表示当前页属于哪个索引                |
| `PAGE_BTR_SEG_LEAF` |   `10`字节   |          B+树叶子段的头部信息，仅在B+树的Root页定义          |
| `PAGE_BTR_SEG_TOP`  |   `10`字节   |         B+树非叶子段的头部信息，仅在B+树的Root页定义         |

### File Header（文件头部）

File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等问题，这个部分占用固定的`38`个字节，是由下边这些内容组成的：

|                名称                | 占用空间大小 |                             描述                             |
| :--------------------------------: | :----------: | :----------------------------------------------------------: |
|     `FIL_PAGE_SPACE_OR_CHKSUM`     |   `4`字节    |                   页的校验和（checksum值）                   |
|         `FIL_PAGE_OFFSET`          |   `4`字节    |                             页号                             |
|          `FIL_PAGE_PREV`           |   `4`字节    |                        上一个页的页号                        |
|          `FIL_PAGE_NEXT`           |   `4`字节    |                        下一个页的页号                        |
|           `FIL_PAGE_LSN`           |   `8`字节    | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
|          `FIL_PAGE_TYPE`           |   `2`字节    |                          该页的类型                          |
|     `FIL_PAGE_FILE_FLUSH_LSN`      |   `8`字节    | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` |   `4`字节    |                       页属于哪个表空间                       |

- FIL_PAGE_SPACE_OR_CHKSUM	

  这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为`校验和`。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。

  作用：InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在**修改后的某个时间需要把数据同步到磁盘中**。但是在同步了一半的时候断电了，造成了该页传输的不完整。
  为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。

- FIL_PAGE_OFFSET：每一个`页`都有一个单独的页号，就跟你的身份证号码一样，`InnoDB`通过页号来可以唯一定位一个`页`

- FIL_PAGE_TYPE：这个代表当前`页`的类型，`InnoDB`为了不同的目的而把页分为不同的类型

  |         类型名称          | 十六进制 | 描述                             |
  | :-----------------------: | :------: | :------------------------------- |
  | `FIL_PAGE_TYPE_ALLOCATED` |  0x0000  | 最新分配，还没使用               |
  |    `FIL_PAGE_UNDO_LOG`    |  0x0002  | Undo日志页                       |
  |     `FIL_PAGE_INODE`      |  0x0003  | 段信息节点                       |
  | `FIL_PAGE_IBUF_FREE_LIST` |  0x0004  | Insert Buffer空闲列表            |
  |  `FIL_PAGE_IBUF_BITMAP`   |  0x0005  | Insert Buffer位图                |
  |    `FIL_PAGE_TYPE_SYS`    |  0x0006  | 系统页                           |
  |  `FIL_PAGE_TYPE_TRX_SYS`  |  0x0007  | 事务系统数据                     |
  |  `FIL_PAGE_TYPE_FSP_HDR`  |  0x0008  | 表空间头部信息                   |
  |   `FIL_PAGE_TYPE_XDES`    |  0x0009  | 扩展描述页                       |
  |   `FIL_PAGE_TYPE_BLOB`    |  0x000A  | 溢出页                           |
  |     `FIL_PAGE_INDEX`      |  0x45BF  | 索引页，也就是我们所说的`数据页` |

- FIL_PAGE_PREV 和 FIL_PAGE_NEX

  `InnoDB`都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，**保证这些页之间不需要是物理上的连续，而是逻辑上的连续**。

  ![image-20230617165732585](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171657650.png)

### File Trailer

我们都知道`InnoDB`存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以`页`为单位把数据加载到内存[buffer pool]中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？

因此，在每个页的尾部都加了一个`File Trailer`部分，这个部分由`8`个字节组成，可以分成2个小部分：

- 前4个字节代表页的校验和

  这个部分是和`File Header`中的校验和相对应的。

  如果完全同步成功，则页的首部和尾部的校验和应该是一致的。

  如果写了一半儿断电了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trailer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN)

  这个部分也是为了校验页的完整性的，如果LSN值校验不成功的话，就说明同步过程出现了问题。

## 区

### 基本介绍

`B+`树的每一层中的页都会形成一个双向链表，如果是以`页为单位`来分配存储空间的话，双向链表相邻的两个页之间的`物理位置可能离得非常远`。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的`随机I/O`。再一次强调，磁盘的速度和内存的速度差了好几个数量级，`随机I/O是非常慢`的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的`顺序I/O`。

一个区就是物理位置上连续的`64个页`。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=`1MB`。

在表中`数据量大`的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照`区为单位分配`，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成`一点点空间的浪费`（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，`功大于过`！

不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：

![image_1cri1nutcorp5ghf5c7vqagt1j.png-71.4kB](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306171706838.webp)

> 记忆点：表空间被划分为许多连续的`区`，每个区默认由64个页组成[1MB]，每256个区划分为一组，每个组的最开始的几个页面类型是固定的。

### 区的分类

区大体上可以分为4种类型：

- `空闲的区(FREE)`：现在还没有用到这个区中的任何页面。
- `有剩余空间的碎片区(FREE_FRAG)`：表示碎片区中还有可用的页面。
- `没有剩余空间的碎片区(FULL_FRAG)`：表示碎片区中的所有页面都被使用，没有空闲页面。
- `附属于某个段的区(FSEG)`：每一索引都可以分为叶子节点段和非叶子节点段

处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，直属于表空间。而处于`FSEG`状态的区是附属于某个段的。

## 段

对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的`叶子节点`和`非叶子节点`进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个`段（segment）`，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个`叶子节点段`，一个`非叶子节点段`。

除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有`数据段`、`索引段`、`回滚段`。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。

在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。

段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。



### 碎片区

默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以**默认情况下一个只存在几条记录的小表也需要2M的存储空间么？**以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常`纯粹`的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。

为了考虑以完整的区为单位分配给某个段对于`数据量较小`的表太浪费存储空间的这种情况，InnoDB提出了一个`碎片（fragment）区`的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。`碎片区直属于表空间`，并不属于任何一个段。

所以此后为某个段分配存储空间的策略是这样的：

- 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了`32个碎片区`页面之后，就会申请以完整的区为单位来分配存储空间。

所以现在段不能仅定义为是某些区的集合，更精确的应该是`某些零散的页面`已经`一些完整的区`的集合。

## 小结

页：就是病房 [16KB]
区：就是楼层（比如1楼、2楼）[64*16KB=1M]
组：呃，256层为一组。 那1到256层是一组；257到512层是一组；513到768层是一组。一栋楼共3组
表空间：整栋楼就是表空间

以上 页、区、组、表空间 都是物理上存在的

-----

段：就是我们上面分的 感冒科、发烧科、腹泻科。一个表空间有几个段？ 回滚日志段、每个索引分2个段（叶子节点一个、非叶子节点一个），如果有3个索引，那就是3*2 = 6个段

段是逻辑上存在的，不是物理上存在的。也就是说，没有固定说那些楼层固定是感冒科的，如果感冒的人多了，就继续找空的楼层划定为感冒科

页类型：这里的病房 如，住感冒的病房、住发烧的病房 就是mysql的不同的页类型，如 回滚日志页、叶子节点页、目录项页

----

碎片区：就是1楼综合科，有各种类型的病房，可以住各种类型的病人







