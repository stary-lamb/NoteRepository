---
title: InnoDB存储引擎（上）
date: 2023-06-16
---

## InnoDB 架构

从 MySql 官方文档中的配图可以看到，InnoDB 引擎的架构分为内存结构和磁盘结构。由于存储引擎仅负责数据的存储和提取工作，因此其设计非常简单和纯粹。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306210925396.png" alt="img" style="zoom: 67%;" />

##  内存架构

InnoDB 内存结构主要分为：Buffer Pool、Change Buffer、Adaptive Hash Index 和 Log Buffer。

### Buffer Pool

**Buffer Pool** [缓冲池] 是主内存中的一块区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作的时候，先操作的就是内存中缓冲池的数据，如果缓冲池没有数据，就从磁盘加载然后缓存起来，然后以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。

如果没有缓冲池，那么我们进行增删改查的时候，每次数据库都需要操作磁盘空间，就会存在大量的磁盘IO，在业务系统比较复杂的场景，产生的IO还是随机IO

在图中我们可以发现里面有一个一个的块，实际上它是一个一个的页，底层它采用链表数据结构管理Page。

根据状态，可以把Page分为三种类型（也就是图中的不同的三种颜色）：

1. **free page**：空闲page，即申请了这部分空间，但是还没有使用
2. **clean page**：尽管该Page被使用过，但是它的数据没有被修改，即还可用
3. **dirty page**：脏页，数据被修改过，页中的数据与磁盘的数据不一致

默认情况下 Buffer Pool 只有 128M 大小。可以在启 动服务器的时候配置 `innodb_buffer_pool_size` 参数的值，就像这样： [server] `innodb_buffer_pool_size = 268435456`  

![img](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306210952841.jpeg)

#### 内部结构

Buffer Pool 中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 16KB 。为了更好的管理这些在 Buffer Pool 中的缓存
页，在InnoDB存储引擎中每一个缓存页都创建了一些所谓的 `控制信息`，这些控制信息包括**该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN**。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306210959388.webp" alt="image_1d15mh3d4oadq0e1qpme22u8i61.png-47.4kB" style="zoom:67%;" />

每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，自然就用不到，这个用不到的那点儿内存空间就被称为`碎片`了。如果你把`Buffer Pool`的大小设置的刚刚好的话，也可能不会产生`碎片`。

#### free 链表

当我们最初启动 MySQL 服务器的时候，需要完成对 **Buffer Pool 的初始化过程**，就是先向操作系统申请 Buffer Pool 的内存空间，然后把它划分成若干对控制块和缓存页。这个时候缓存页还没用上，但随着程序的不断运行，会不断的有磁盘上的页被缓存到 Buffer Pool中，那么怎么区分`Buffer Pool`中哪些缓存页是空闲的，哪些已经被使用了呢？

当然是靠控制块了，我们可以把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作 **free链表（或者说空闲链表）**。刚刚完成初始化的Buffer Pool中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到 free链表 中，假设该 Buffer Pool 中可容纳的缓存页数量为n，那增加了 free链表 **的效果图就是这样的**

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211006192.webp" alt="image_1d155te021bmgjt09mo1lln17dum.png-132.6kB" style="zoom: 80%;" />



首先每一个控制块都有两个指针，用来关联空首先每个控制块都有两个 指针，用来关联空闲的上下两个控制块。InnoDB再定义了一个free控制块的**基点**，将所有空闲的控制块串联成双向链表。

有了这个 `free链表` 之后事儿就好办了，每当需要从磁盘中加载一个页到 `Buffer Pool` 中时，就从 `free链表` 中**取一个空闲的缓存页**，并且把该缓存页对应的`控制块`的信息填上（就是该页所在的表空间、页号之类的信息），然后**把该缓存页对应的 `free链表` 节点从链表中移除，表示该缓存页已经被使用了**。 

> 注意：链表基节点占用的内存空间并不大，在MySQL5.7.21这个版本里，每个基节点只占用40字节大小。后边不同的链表也是如此，它们的基节点和free链表的基节点的内存分配方式是一样一样的，都是单独申请的一块40字节大小的内存空间，并不包含在为Buffer Pool申请的一大片连续内存空间之内。

#### 缓存页的哈希

当我们需要访问某个页中的数据时，就会把该页从磁盘加载到 Buffer Pool 中，如果该页已经在 Buffer Pool 中的话直接使用就可以了，那么我们怎么知道该页在不在 Buffer Pool 中呢?

我们可以用`表空间号 + 页号`作为`key`，`缓存页`作为`value`创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据`表空间号 + 页号`看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从`free链表`中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。

#### flush链表

如果我们修改了 Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为`脏页`（英文名：dirty page ）。这些脏页不会急着加载进磁盘，会等一段时间，有可能一个页累计了好多次的修改，统一刷进磁盘，称为 `刷脏` 。那么问题也随之而来，我怎么知道哪些页是脏页？  

所以，我们不得不再创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫`flush链表`。

链表的构造和`free链表`差不多，假设某个时间点`Buffer Pool`中的脏页数量为`n`，那么对应的`flush链表`就长这样：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211030928.webp" alt="image_1d1589dpqmt5v1849s7614nu23.png-133.5kB" style="zoom: 80%;" />

#### LRU 链表

Buffer Pool 对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了 Buffer Pool 大小，也就是 free链表 中已经没有多余的空闲缓存页的时候岂不是很尴尬，发生了这样的事儿该咋办？当然是把某些旧的缓存页从 Buffer Pool 中移除，然后再把新的页放进来。那么问题来了，移除哪些缓存页呢？

当 Buffer Pool 中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。我们可以再创建一个链表，这个链表是为了`按照最近最少使用`的原则去淘汰缓存页的，所以这个链表可以被称为`LRU链表`（LRU的英文全称：Least Recently Used）。当我们需要访问某个页时，可以这样处理`LRU链表`：

- 如果该页不在Buffer Pool 中，在把该页从磁盘加载到 Buffer Pool 中的缓存页时，就把该缓存页对应的 `控制块` 作为节点塞到链表的头部。
- 如果该页已经缓存在 Buffer Pool 中，则直接把该页对应的`控制块`移动到`LRU链表`的头部。

> 也就是说：只要我们使用到某个缓存页，就把该缓存页调整到`LRU链表`的头部，这样`LRU链表`尾部就是最近最少使用的缓存页。所以当`Buffer Pool`中的空闲缓存页使用完时，到`LRU链表`的尾部找些缓存页淘汰就可以了。

但上述的 `LRU链表` 存在这两种比较尴尬的问题：

- 预读（英文名：read ahead）。所谓预读，就是 InnoDB 认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到Buffer Pool中。

  `预读`本来是个好事儿，如果预读到`Buffer Pool`中的页成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢？

  这些预读的页都会放到`LRU`链表的头部，但是如果此时`Buffer Pool`的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在`LRU链表`尾部的一些缓存页会很快的被淘汰掉，也就是所谓的`劣币驱逐良币`，会大大降低缓存命中率。

- 全表扫描

  当我们没加索引去全部扫描一个数据，那么全表的页都会被加载进缓存，就把我们的lru全部刷新一遍了，其他本来热点的数据都会被迫被替换，LRU链表等于换了一次血，这严重的影响到其他查询对 Buffer Pool 的使用，从而大大降低了缓存命中率。



为了解决上诉LRU链表出现的问题，在设计 InnoDB 引擎的过程中，把 LRU链表 按照一定比例分成两截，分别是：

- 一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做`热数据`，或者称`young区域`。
- 另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做`冷数据`，或者称`old区域`。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211044917.webp" alt="image_1d15fb53d2lf13ovglg1rnv1h2n2g.png-116.5kB" style="zoom: 80%;" />

默认情况下，`old`区域在`LRU链表`中所占的比例是`37%`，也就是说`old`区域大约占`LRU链表`的`3/8`。这个比例我们是可以设置的，我们可以在启动时修改`innodb_old_blocks_pct`参数来控制`old`区域在`LRU链表`中所占的比例，比方说这样修改配置文件：

~~~ ini
[server]
innodb_old_blocks_pct = 40
~~~

- 针对预读的页面可能不进行后续访问情况的优化

  当磁盘上的某个页面在初次加载到 Buffer Pool 中的某个缓存页时，**该缓存页对应的控制块会被放到old区域的头部**。后续有被访问，才会到 `young区`。这样**针对预读到Buffer Pool 却不进行后续访问的页面就会被逐渐从 old区域 逐出**，而不会影响`young`区域中被使用比较频繁的缓存页。

- 针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化

  在进行全表扫描时，虽然首次被加载到Buffer Pool 的页被放到了`old`区域的头部，但是后续会被马上访问到，每次进行访问的时候又会把该页放到`young`区域的头部，这样仍然会把那些使用频率比较高的页面给顶下去。所以 MySQL 提供了一个参数`innodb_old_blocks_time` 说的是，在加载进缓存页后的多少秒，再次访问，才能把页面变到 `young`区 。
  
- 针对`young`区域的优化

  对于`young`区域的缓存页来说，我们每次访问一个缓存页就要把它移动到`LRU链表`的头部。

  所以MySQL也作了相关的优化，只有被访问的缓存页位于`young`区域的`1/4`的后边，才会被移动到`LRU链表`头部，这样就可以降低调整`LRU链表`的频率，从而提升性能（也就是说如果某个缓存页对应的节点在`young`区域的`1/4`中，再次访问该缓存页时也不会将其移动到`LRU`链表头部）。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211121949.webp" alt="yuque_diagram (6).jpg" style="zoom:50%;" />

#### 刷新脏页到磁盘

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：

- 从`LRU链表`的冷数据中刷新一部分页面到磁盘。

  后台线程会定时从`LRU链表`尾部开始扫描一些页面，扫描的页面数量可以通过系统变量`innodb_lru_scan_depth`来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为`BUF_FLUSH_LRU`。

- 从`flush链表`中刷新一部分页面到磁盘。

  后台线程也会定时从`flush链表`中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为`BUF_FLUSH_LIST`。

有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到`Buffer Pool`时没有可用的缓存页，这时就会尝试看看`LRU链表`尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将`LRU链表`尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为`BUF_FLUSH_SINGLE_PAGE`。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211121653.webp" alt="yuque_diagram (5).jpg" style="zoom:33%;" />



### Log Buffer

InnoDB 使用 Log Buffer 来缓冲日志文件的写入操作。内存写入加上日志文件顺序写的特点，使得 InnoDB 日志写入性能极高。

对于任何修改操作，都将录入诸如 redo log 与 undo log 这样的日志文件中，因此日志文件的写入操作非常频繁，却又十分零散。这些文件都存储在磁盘中，因此日志记录将引发大量的磁盘 IO。Log Buffer 将分散的写入操作放在内存中，通过定期批量写入磁盘的方式提高日志写入效率和减少磁盘 IO。

![Log Buffer 逻辑结构图 -- Zohar Yip](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211116919.webp)

这种将分散操作缓冲为批量操作的优化方式将增加数据丢失的风险，**事务提交的时候必将将操作写入日志中**，此时日志文件若未落盘而系统崩溃，则相关操作将丢失而无法恢复。而使用 `write` 方式将 Log Buffer 写入日志文件时，操作系统会将写入操作先写入 OS 缓冲区中，需要调用 `flush` 指令将缓冲区数据刷入文件中，若操作系统在未刷入前崩溃，则同样将导致数据丢失不可恢复。

InnoDB 提供三种 Log Buffer 数据落盘方式：

- 0：**按秒写，按秒刷**。每秒调用 `write()` 写入 OS Buffer 并调用 `flush()` 刷入磁盘。
- 1：**实时写，实时刷**。每次事务提交都调用 `write()` 写入 OS Buffer 并调用 `flush()` 刷入磁盘。
- 2：**实时写，延迟刷**。每次事务提交都调用 `write()` 写入 OS Buffer，但每秒调用 `flush()` 刷入磁盘。

## 特性

### 插入缓冲（Change Buffer）  

MySQL5.5之前的版本中其实都叫做 Insert Buffer，之后优化为 `Change Buffer` 可以看做是 Insert Buffer 的升级版。

插入缓冲（ Insert Buffer）这个其实只针对 INSERT 操作做了缓冲，而Change Buffer 对INSERT、DELETE、UPDATE都进行了缓冲，所以可以统称为写缓冲，其可以分为：

- Insert Buffer
- Delete Buffer
- Purgebuffer

Insert Buffer 就是用于提升非聚集索引页的插入性能的，其数据结构类似于数据页的一个B+树，Insert buffer的信息一部分在内存中，另外一部分像数据页一样，存在于物理页中，物理存储在共享表空间ibdata1中。

在Innodb中，如果表中有个主键索引，还有个二级索引。我们插入一条数据，需要插入主键中，还需要插入二级索引，如果二级索引插入时还涉及页分裂，就是很慢的。 

Innodb存储引擎针对这种情况，设计了Insert Buffer，对于非聚集索引的插入或者更新操作，不是每一次插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，如果不在，则先放入一个Insert buffer中，告诉数据库这个非聚集的索引已经插入到了叶子节点，实际上并没有插入，只是存放在另外一个位置，然后再以一定的频率和情况进行 Insert buffer 和辅助索引叶子节点合并操作。这种时候，经常能将多条记录的插入合并到一个操作中，这样就大大提高了非聚集索引离散插入的性能。  

Insert buffer 只适用非唯一的索引上，原因如下：

- primary key 是按照递增的顺序进行插入的，异常插入聚族索引一般也顺序的，非随机IO
- 写唯一索引要检查记录是不是存在，所以在修改唯一索引之前，必须把修改的记录相关的索引页读出来才知道是不是唯一，这样Insert buffer就没意义了，要读出来(随机IO)

那么什么时候进行合并呢？  

- 当辅助索引页被读取到缓冲池中时
- Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时，一般的阈值是辅助索引页空间的1/32
- Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作。

### 自适应哈希（Adaptive Hash Index）

Innodb的索引结构本事是不支持hash的，但是可以支持自适应hash。

我们知道hash的查询速度是最快的O（1）,而b+树可能还需要三层四层，如果是二级索引，还需要 回表，特别慢。 innodb存储引擎会监控对表上个索引页的查询。

如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称为为自适应哈希索引。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。innodb存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。

就像这样它会占用buffer pool的空间，直接指向已有的缓存页。

AHI有一个要求，即对这个页的连续访问模式必须是一样的，例如(a,b)的联合索引页，其访问模式可以是以下情况

- where a=xxx
- where a=xxx and b=xxx

访问模式一样指的是查询条件一样，若交替进行上述两种查询，那么innodb存储引擎不会对该页构造AHI，此外AHI还有如下的要求：    

- 以该模式访问了100次
- 页通过该模式访问了N次，其中N=页中记录 * 1/16  

我们可以通过 `show engine innodb status` 命令查看当前AHI的使用情况：  

~~~ mysql
mysql> show engine innodb status\G
……
Hash table size 34673, node heap has 0 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
1、34673：字节为单位，占用内存空间总量
2、通过hash searches、non-hash searches计算自适应hash索引带来的收益以及付出，确定是否开启自适应hash索引
~~~

它的一些 缺点 ：

1. 只适用与等值查询
2. Hash自适应索引会占用innodb buffer pool；
3. 自适应hash索引只适合搜索等值的查询，如select * from table where index_col='xxx'，而对于其他查找类型，如范围查找，是不能使用的；
4. 极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读  

> 默认开启，建议关掉，意义不大。可以通过 set global innodb_adaptive_hash_index=off/on 关闭和打开该功能。  

### 两次写

#### 出现的问题

脏页会在某些场景下进行刷盘，将缓冲池内的脏页数据落地到磁盘。

因为存储引擎缓冲池内的数据页大小默认为16KB，而文件系统一页大小为4KB，所以在进行刷盘操作时，就有可能发生如下场景：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211145476.webp" alt="img" style="zoom:50%;" />



如图所示，数据库准备刷新脏页时，需要四次IO才能将16KB的数据页刷入磁盘。

但当执行完第二次IO时，数据库发生意外宕机，导致此时才刷了2个文件系统里的页，这种情况被称为写失效（partial page write）。

此时重启后，磁盘上就是不完整的数据页，就算使用redo log也是无法进行恢复的。

如果写脏页的时候发生宕机，在重启后使用下备份先恢复下数据页在写磁盘就可以了，其实这就是`Double Write`

#### Double Write

在数据库进行脏页刷新时，如果此时宕机，有可能会导致磁盘数据页损坏，丢失我们重要的数据。此时就算重做日志也是无法进行恢复的，因为重做日志记录的是对页的物理修改。

其实就是在重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211148442.webp" alt="img" style="zoom: 50%;" />

如图，其实Double Write 分为了两个组成部分：

- 内存中的double write buffer
- 物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB

可以看出，有了Double write后的脏页刷新流程就是多了几步操作：

1. 在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的Double write buffer
2. 通过Double write buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题.

**Double write崩溃恢复**

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202306211149672.webp" alt="img" style="zoom: 50%;" />

如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的Double write中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。

