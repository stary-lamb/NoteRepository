---
title: 对象内存布局
date: 2023-3-5
---

## 对象实例化

### 创建对象

#### new

- 最常见的方式
- 变形1：Xxx的静态方法
- 变形2：XxxBuilder/XxxFactory的静态方法

#### Class的newInstance()

Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public

#### Constructor的newInstance(Xxx)

Constructor的newInstance(Xxx)：反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更广

#### 使用clone()

使用clone()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone()，默认浅拷贝

#### 使用反序列化

使用反序列化：从文件中、数据库中、网络中获取一个对象的二进制流，反序列化为内存中的对象

#### 第三方库Objenesis

第三方库Objenesis，利用了asm字节码技术，动态生成Constructor对象

### 从字节码角度分析对象创建过程

下面从最简单的Object ref = new Object()； 代码进行分析，利用javap -verbose -p 命令查看对象创建的字节码如下：

![图像](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202305191226152.png)

- NEW ：如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object 开始到本类路径上的所有属性值都要分配内存。分配完毕之后，进行零值初始化。在分配过程中，注意引用是占据存储空间的，它是一个变量，占用4个字节。这个指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。
- DUP ：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量。如果< init> 方法有参数，还需要把参数压人操作栈中。两个引用变量的目的不同，其中压至底下的引用用于赋值，或者保存到局部变量表，另一个栈顶的引用变量作为句柄调用相关方法。
- INVOKESPECIAL ：调用对象实例方法，通过栈顶的引用变量调用< init> 方法。

> 补充：
> < clinit> 是类初始化时执行的方法， 而< init> 是对象初始化时执行的方法。

### 从执行步骤角度分析对象创建过程

#### 1. 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。

- 如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class 文件。
- 如果没有找到文件，则抛出ClassNotFoundException 异常。
- 如果找到，则进行类加载，并生成对应的Class类对象。

#### 2.为对象分配内存

首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。

如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

Java虚拟机通常采用的是两种分配方式：指针碰撞（Bump the Pointer）和空闲列表（Free List）。

**指针碰撞**

如果内存规整，使用指针碰撞

如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。

意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。 

如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有compact（整理）过程的收集器时，使用指针碰撞。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202305191232156.png" alt="image-20230519123215065" style="zoom:80%;" />

**空闲列表**

如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配

如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为”空闲列表（Free List）”。

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202305191233729.png" alt="image-20230519123305634" style="zoom:80%;" />

> 说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

#### 3.处理并发安全问题

在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。 虚拟机采用了两种方式解决并发问题:

- CAS ( Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性;
- TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。

#### 4.初始化分配到的空间

内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### 5.设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

#### 6.执行init方法进行初始化

在Java程序的视角看来，初始化才正式开始。**初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。**

因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

## 对象的内存布局

### 对象头(Header)

对象头主要包括两部分。

- 一个是对象自身的运行时元数据(mark word)
  - 哈希值(hashcode)：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用
  - GC分代年龄：对象首先是在Eden中创建的，在经过多次GC后，如果没有被进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入养老区
  - 锁状态标志，在同步中判断该对象是否是锁线程持有的锁
  - 线程偏向ID
  - 偏向时间戳
- 另一个是类型指针，指向元数据区的类元数据InstanceKlass，确定该对象所属的类型

此外，如果对象是一个数组，对象头中还必须有一块用于记录数组的长度的数据。

因为正常对象元数据就知道对象的确切大小。所以数组必须得知道长度。

### 实例数据(Instance Data)

它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）。

**这里需要遵循的一些规则：**

1. 相同宽度的字段总是被分配在一起
2. 父类中定义的变量会出现在子类之前（因为父类的加载是优先于子类加载的）
3. 如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙

### 对齐填充(Padding)

对齐填充不是必须的，也没特别含义，仅仅起到占位符的作用 

## 对象访问定位

### 方式1：句柄访问

- 堆需要划分出一块内存来做句柄池，reference中存储对象的句柄池地址，句柄中包含对象实例与类型数据各自具体的地址信息。
- 好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针，reference本身不需要被修改。

![image-20230519124341789](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202305191243834.png)

### 方式2：直接使用指针访问

- reference中存储的就是对象的地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。
- 好处：速度更快，java中对象访问频繁，每次访问都节省了一次指针定位的时间开销。

![image-20230519124438202](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202305191244245.png)

### HotSpot使用方式

HotSpot这里主要使用第2种方式：直接指针访问

JVM可以通过对象引用准确定位到Java堆区中的instanceOopDesc对象，这样既可成功访问到对象的实例信息，当需要访问目标对象的具体类型时，JVM则会通过存储在instanceOopDesc中的元数据指针定位到存储在方法区中的instanceKlass对象上。