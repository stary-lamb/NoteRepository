---
title: Java内存模型——JMM
date: 2022-12-25
---

## JMM 基本介绍

JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是**一组约定或规范**。

通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是**围绕多线程的原子性、可见性和有序性展开的**。

**JMM 的作用：**

1. 通过JMM来实现线程和主内存之间的抽象关系。
2. 屏蔽各个硬件平台和操作系统的内存访问差异以实现让 Java程序 在各种平台下都能达到一致的内存访问效果。

## 三大特性

### 可见性

**可见性** 是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM 规定了所有的变量都存储在**主内存**中。

![image-20230107162004835](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202301071620352.png)

Java 中**普通的共享变量不保证可见性**，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现 “脏读”，所以每个线程都有自己的**工作内存**，线程自己的工作内存中保存了该线程使用到的变量的**主内存副本拷贝**，线程对变量的所以操作（读取、赋值等）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程变量值的传递均需要通过主内存来完成。

![image-20230107164942020](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202301071649083.png)



**如果没可见性保证的前提下导致的线程脏读**

1. 主内存中有变量 x，初始值为 0
2. 线程 A 要将 x 加 1，先将 x=0 拷贝到自己的私有内存中，然后更新 x 的值
3. 线程 A 将更新后的 x 值回刷到主内存的时间是不固定的
4. 刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x=2 就会变成 x=1

![image-20230114090305883](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202301140903126.png)

### 原子性

原子性指的是一个操作是不可中断的，即在多线程的环境下，操作不能被其他的线程所干扰。

### 有序性

对于一个线程的执行代码而言，在我们视角中总是习惯性认为**代码的执行总是从上至下，有序执行**，但为了提高性能，编译器和处理器通常会对指令序列进行重新排序。

指令重排**可以保证串行语义的一致性**，但没有义务保证多线程间的语义也一致，即可能产生 “脏读”，也就是说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下的顺序执行，执行的顺序会被编译器和处理器所优化。

![image-20230114092812319](https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202301140928370.png)

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。

处理器在进行重排序时必须要考虑指令之前的**数据依赖性**。

多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

## JMM规范下，多线程对变量的读写过程

### 读取过程

JVM 运行程序的实体是线程，而每个线程创建 JVM 都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，**但线程对变量操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存**，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的**变量副本拷贝**，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问的过程如下图：

<img src="https://qijiayi-image.oss-cn-shenzhen.aliyuncs.com/img/202301141022875.png" alt="image-20230114102257778" style="zoom:67%;" />

**JMM定义了线程和主内存之间的抽象关系**

1. 线程之间的共享变量存储在主内存中（从硬件角度来说就是内存条）
2. 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本（从硬件的角度来说就是 CPU的缓存 ，比如寄存器、L1、L2、L3缓存等）

### 总结

1. 所有共享变量都储存在**物理主内存中**
2. 每个线程都有自己独立工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）
3. 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写（不能越级）
4. 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）

## 先行发生原则（happens-before）

在 JMM 中，如果一个操作执行的结果需要对另一个操作可见性 或者 代码重排序，那么这两个操作之间必须存在happens-before关系。

**先行发生原则说明**

先行发生原则是判断数据是否存在竞争，线程是否安全的非常有用的手段，依赖这个原则，我们可以通过几条简单的规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入 Java 内存模型苦涩难懂的底层编译原理之中。

### happens-before 总原则

- 如果一个操作hanppens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在 hanppens-before 关系，并不意味着一定要按照 hanppens-before 原则制定的顺序来执行。如果重排序之后的执行结果与按照 hanppens-before 关系来执行的结果一致，那么这种重排序不违法。

### happens-before 八条原则

**1. 次序原则**

一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作。如：前一个操作把变量 X 赋值为1，那后面一个操作肯定能知道 X 已经变成了1。

**2. 锁定规则**

一个 unLock 操作先行发生于后面((这里的 “后面” 是指时间上的先后))对同一个锁的 lock 操作。

~~~ java
public class HappenBeforeDemo {
    static Object objectLock = new Object();

    public static void main(String[] args) throws InterruptedException {
        
        //对于同一把锁objectLock，threadA一定先unlock同一把锁后B才能获得该锁，   A 先行发生于B
        synchronized (objectLock) {

        }
    }
}
~~~

**3. volatile变量规则**

对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的 “后面” 同样是指时间上的先后。

| 第一个操作 | 第二个操作：普通读写 | 第二个操作：volatile读 | 第二个操作：volatile写 |
| ---------- | -------------------- | ---------------------- | ---------------------- |
| 普通写     | 可以重排             | 可以重排               | 不可以重排             |
| volatile读 | 不可以重排           | 不可以重排             | 不可以重排             |
| volatile写 | 可以重排             | 不可以重排             | 不可以重排             |

- 当第一个操作为`volatile读`时，不论第二个操作是什么，都不能重排序。这个操作保证了`volatile读`之后的操作不会被重排到`volatile读`之前。
- 当第二个操作为`volatile写`时，不论第一个操作是什么，都不能重排序。这个操作保证了`volatile写`之前的操作不会被重排到`volatile写`之后。
- 当第一个操作为`volatile写`时，第二个操作为volatile读时，不能重排。

**4. 传递规则**

如果操作A先行发生于操作B，而操作B又先行发生与操作C，则可以得出操作A先行发生于操作C。

**5. 线程启动规则（Thread Start Rule）**

Thread 对象的start() 方法先行发生于此线程的每一个动作。

**6. 线程中断规则（Thread Iterruption Rlue）**

对线程 interrupt() 方法的调用先行发生于被中单线程的代码检测到中断事件的发生；可以通过 Thread.interrupted() 检测到是否发生中断。

**7. 线程终止规则（Thread Termination Rule）**

线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。

**8. 对象终结规则(Finalizer Rule)**

一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始；对象没有完成初始化之前，是不能调用 finalized() 方法。



























































